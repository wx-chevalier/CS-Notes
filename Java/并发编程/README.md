# Java 并发编程

![Java 并发编程](https://s2.ax1x.com/2019/09/02/nCLmb4.png)

# Java 内存模型（Java Memory Model, JMM）

Java 内存模型着眼于描述 Java 中的线程是如何与内存进行交互，以及单线程中代码执行的顺序等，并提供了一系列基础的并发语义原则；最早的 Java 内存模型于 1995 年提出，致力于解决不同处理器/操作系统中线程交互/同步的问题，规定和指引 Java 程序在不同的内存架构、CPU 和操作系统间有确定性地行为。在 Java 5 版本之前，JMM 并不完善，彼时多线程往往会在共享内存中读取到很多奇怪的数据；譬如，某个线程无法看到其他线程对共享变量写入的值，或者因为指令重排序的问题，某个线程可能看到其他线程奇怪的操作步骤。

Java 内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从 happens-before 原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

Java 内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。

- 线程内的代码能够按先后顺序执行，这被称为**程序次序规则**。
- 对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做**管程锁定规则**。
- 前一个对 volatile 的写操作在后一个 volatile 的读操作之前，也叫 **volatile 变量规则**。
- 一个线程内的任何操作必需在这个线程的 start() 调用之后，也叫作**线程启动规则**。
- 一个线程的所有操作都会在线程终止之前，**线程终止规则**。
- 一个对象的终结操作必需在这个对象构造完成之后，也叫**对象终结规则**。

对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。

# 线程安全

线程如果都各自干活互不搭理的话自然相安无事，但多数情况下线程直接需要打交道，而且需要分享共享资源，那么这个时候最核心的就是线程安全了。当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。

- 无状态：这个有点函数式编程的味道，总之就是线程只有入参和局部变量，如果变量是引用的话，确保变量的创建和调用生命周期都发生在线程栈内，就可以确保线程安全。

- 无共享状态：完全要求线程无状态比较难实现，必要的状态是无法避免的，那么我们就必须维护不同线程之间的不同状态，这可是个麻烦事。幸好我们有 ThreadLocal 这个神器，该对象跟当前线程绑定，而且只对当前线程可见，完美解决了无共享状态的问题。

- 不可变状态：最后实在没办法避免状态共享，在线程之间共享状态，最怕的就是无法确保能维护好正确的读写顺序，而且多线程确实也无法正确维护好这个共享变量。那么我们索性粗暴点，把共享的状态定位不可变，比如价格 final 修饰一下，这样就达到安全状态共享。

- 线程同步：锁、事件等，一个线程通常也不是所有步骤都需要共享状态，而是部分环节才需要的，那么我们把共享状态的代码拆开，无共享状态的那部分自然不用关心，而共享状态的小段代码，则通过加入消息组件来传递状态。这个设计到并发模式的流水线编程模式，下文并发模式会重点介绍。

我们最早接触线程安全可能是 JDK 提供的一些号称线程安全的容器，比如 Vetor 较 ArrayList 是线程安全，HashTable 较 HashMap 是线程安全？其实线程安全类并不代表也不等同线程安全的程序，而线程不安全的类同样可以完成线程安全的程序。我们关注的也就是写出线程安全的程序，那么如何写出线程安全的代码呢，核心就是避免共享的可变状态。

synchronized 同步，该关键字确保代码块同一时间只被一个线程执行，在这个前提下再设计符合线程安全的逻辑：

- 对象：对象加锁，进入同步代码块之前获取对象锁
- 实例方法：对象加锁，执行实例方法前获取对象实例锁
- 类方法：类加锁，执行类方法前获取类锁

volatile 确保每次操作都能强制同步 CPU 缓存和主存直接的变量。而且在编译期间能阻止指令重排。读写并发情况下 volatile 也不能确保线程安全。

JUC 里面提供大量的并发容器，涉及到线程交互的时候，使用安全容器可以避免大部分的错误，而且大大降低了代码的复杂度。

- 通过 synchronized 给方法加上内置锁来实现线程安全的类如 Vector，HashTable,StringBuffer
- AtomicXXX 如 AtomicInteger
- ConcurrentXXX 如 ConcurrentHashMap
- BlockingQueue/BlockingDeque
- CopyOnWriteArrayList/CopyOnWriteArraySet
- ThreadPoolExecutor

# 链接

- https://mp.weixin.qq.com/s/w-C9QkMQhgnAChnRrsrXIw
- https://www.jianshu.com/p/3f6b26ee51ce
